/-
Copyright (c) 2025 Bhavik Mehta. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Bhavik Mehta, Kevin Buzzard
Modified by: Trevor Hyde
-/
import Mathlib.Tactic

set_option linter.unusedTactic false

/-
## Groups and Lattices
## Part 3: Subgroups and Group Homomorphisms
-/


-- Let `G` be a group, and let `H` be a subgroup of `G`.
variable {G : Type} [Group G]
variable {H : Subgroup G}
-- Note that `H` is not an instance of the class `Group`. This is a bit confusing. The issue is that any instance of `Group` must be a `Type`, while `H` is a term of type `Subgroup G`. However, we can coerce `H` into being a group like this:

#check H       -- `H : Subgroup G`
#check Group H -- `Group ↑H : Type`

-- Subgroups of `G` behave similarly to subsets of a type `X`. For example, if `A : Set X`, then all the elements of `A` have type `X`. If `H : Subgroup G`, then every element of `H` has type `G`.

/-
The defining properties of a subgroup are:
1. (`Closure`) If `a, b ∈ H`, then `a * b ∈ H`.
  `mul_mem : a ∈ H → b ∈ H → a * b ∈ H`
2. (`One`) The identity belongs to `H`, `1 ∈ H`.
  `one_mem : 1 ∈ H`
3. (`Closed Under Inverses`) If `a ∈ H`, then `a⁻¹ ∈ H`.
  `inv_mem : a ∈ H → a⁻¹ ∈ H`

A convenient way to cite these properties is to use the dot notation like this:
-/
example (a b : G) (ha : a ∈ H) (hb : b ∈ H) : a * b ∈ H := by
  exact H.mul_mem ha hb

-- Try using these properties to solve this one.
example
  (a b c : G)
  (ha : a ∈ H)
  (hb : b ∈ H)
  (hc : c ∈ H)
  : a * b⁻¹ * 1 * (a * c) ∈ H := by
    sorry
    done

/-
`Subgroup G` forms a complete lattice. If `H K : Subgroup G`, then `H ⊓ K` is defined to be the intersection of `H` and `K` and `H ⊔ K` is defined to be the subgroup of `G` generated by `H` and `K`. Note that this is typically not the union of `H` and `K`. The bottom `⊥` of `Subgroup G` is the trivial subgroup, and the top `⊤` is `G` itself, viewed as a subgroup of `G`.
-/

-- This one is true by definition
example (H K : Subgroup G) (a : G) : a ∈ H ⊓ K ↔ a ∈ H ∧ a ∈ K := by
  rfl

-- Try this one:
example (H K : Subgroup G) (a : G) : a ∈ H ∨ a ∈ K → a ∈ H ⊔ K := by
  sorry
  done

example : a ∈ (⊥ : Subgroup G) ↔ a = 1 := by
  exact Subgroup.mem_bot

example : a ∈ (⊤ : Subgroup G) := by
  exact Subgroup.mem_top a

/-
# Conjugating a subgroup by an element.

Let's define the conjugate `gHg⁻¹` of a subgroup `H` by an element `g`. To do this we need to know how to *make* subgroups, not just prove things about them. To create a subgroup of `G`, you need to give a subset of `G` and then a proof that the subset satisfies the three axioms `one_mem`, `inv_mem` and `mul_mem` for subgroups. If `H : subgroup G` and `x : G` then the *conjugate* of `H` by `g` is the set `{a : G | ∃ h, h ∈ H ∧ a = g * h * g⁻¹}`. Let's show that this set satisfies the axioms for a subgroup.
-/
variable {g: G}

def conjugate_set (H : Subgroup G) (g : G) : Set G := {a : G | ∃ h, h ∈ H ∧ a = g * h * g⁻¹}

theorem conjugate.one_mem : (1 : G) ∈ conjugate_set H g := by
  sorry
  done

theorem conjugate.inv_mem (hy : y ∈ conjugate_set H g) : y⁻¹ ∈ conjugate_set H g := by
  sorry
  done

theorem conjugate.mul_mem
  (hy : y ∈ conjugate_set H g)
  (hz : z ∈ conjugate_set H g)
  : y * z ∈ conjugate_set H g := by
    sorry
    done

-- Now we put everything together:
def conjugate (H : Subgroup G) (g : G) : Subgroup G where
  carrier := conjugate_set H g
  one_mem' := conjugate.one_mem
  inv_mem' := conjugate.inv_mem
  mul_mem' := conjugate.mul_mem


-- After we define a new construction like `conjugate`, the next step is to prove some theorems about it. Otherwise, it isn't very useful. What kind of theorems should we prove about conjugates? Below I suggest a few examples.

-- This one is handy: it allows you to use `rw` when faced with goals of the form `a ∈ conjugate H g` to replace it with the definition.
theorem mem_conjugate_iff : a ∈ conjugate H g ↔ ∃ h, h ∈ H ∧ a = g * h * g⁻¹ := by
  rfl

theorem conjugate_mono
  (H K : Subgroup G) (hHK : H ≤ K)
  : conjugate H g ≤ conjugate K g := by
    sorry
    done

theorem conjugate_bot : conjugate ⊥ g = ⊥ := by
  sorry
  done

theorem conjugate_top : conjugate ⊤ g = ⊤ := by
  sorry
  done

theorem conjugate_eq_of_abelian
  (habelian : ∀ a b : G, a * b = b * a)
  : conjugate H g = H := by
    sorry
    done
